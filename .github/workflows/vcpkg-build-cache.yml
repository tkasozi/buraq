name: Build with Vcpkg and CMake (GitHub Packages Caching)

on: [ push, pull_request ]

jobs:
  build:
    runs-on: windows-latest # Or your specific Windows runner if different
    permissions:
      contents: read # Needed for checkout
      packages: write # VERY IMPORTANT: Allows pushing/pulling from GitHub Packages

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: true # If vcpkg is a submodule in your it-tools-editor repo
          path: it-tools-editor
          fetch-depth: '0'

      # Step 1: Set up MSYS2 with essential tools (including Ninja)
      # This replaces the need to find Ninja later.
      - name: Set up MSYS2 with Build Tools
        uses: msys2/setup-msys2@v2
        with:
          msys2-architecture: x86_64
          path-type: minimal
          # Install toolchain, git, and critically, ninja
          install: >
            mingw-w64-x86_64-toolchain
            git
            ninja
          # If you need specific MSYS2 shells for later steps, you can set a default
          # shell: mingw64

      # Step 2: Clone Vcpkg if not part of the main repo as a submodule
      # Adjust 'path' if you place vcpkg elsewhere.
      - name: Clone Vcpkg Repository
        # Only run if vcpkg wasn't checked out as a submodule in the main repo
        if: ${{ github.workspace }}/it-tools-editor/vcpkg != '' && !contains(github.workspace, 'it-tools-editor/vcpkg') # Crude check, refine if needed
        uses: actions/checkout@v4
        with:
          repository: microsoft/vcpkg
          ref: master # Or a specific commit/tag for stability (e.g., '2024.06.20')
          path: vcpkg # Clones vcpkg into ${{ github.workspace }}/vcpkg
          fetch-depth: '0' # Fetch full history

      # Step 3: Bootstrap Vcpkg
      # This compiles the vcpkg executable itself.
      - name: Bootstrap Vcpkg
        run: ${{ github.workspace }}/vcpkg/bootstrap-vcpkg.bat
        shell: cmd # Use cmd shell for .bat file execution

      # Step 4: Cache Vcpkg's Asset Downloads (Optional but Recommended)
      # This caches downloaded source code archives, build tools, etc., preventing re-downloads.
      - name: Cache Vcpkg Asset Downloads
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/vcpkg/downloads # Vcpkg's common asset cache
            ${{ github.workspace }}/vcpkg/toolsrc # Location where vcpkg builds/stores helper tools
          key: ${{ runner.os }}-vcpkg-assets-${{ hashFiles('it-tools-editor/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-assets-

      # CRITICAL MODIFIED STEP: Configure NuGet.Config for GitHub Packages
      # This step creates the package source and user credentials in NuGet.Config
      - name: Configure NuGet for GitHub Packages
        env:
          USERNAME: ${{ github.repository_owner }}
          GH_PACKAGES_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}
        run: |
          # Create NuGet.Config in the user's NuGet configuration directory
          $nugetConfigPath = Join-Path $env:APPDATA "NuGet\NuGet.Config"
          
          $nugetConfigContent = @"
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <packageSources>
              <clear />
              <add key="GitHubPackages" value="https://nuget.pkg.github.com/$env:USERNAME/index.json" />
            </packageSources>
            <packageSourceCredentials>
              <GitHubPackages>
                <add key="Username" value="$env:USERNAME" />
                <add key="ClearTextPassword" value="$env:GH_PACKAGES_TOKEN" />
              </GitHubPackages>
            </packageSourceCredentials>
          </configuration>
          "@
          
          # Ensure the directory exists
          New-Item -ItemType Directory -Force -Path (Split-Path $nugetConfigPath)
          $nugetConfigContent | Out-File $nugetConfigPath
          Write-Host "Created NuGet.Config at $nugetConfigPath"
          
      # NEW CRITICAL STEP: Set API Key for the GitHub Packages Source using nuget.exe setapikey
      # This explicitly tells nuget.exe about the API key for the source.
      - name: Set NuGet API Key for GitHub Packages
        env:
          VCPKG_EXE: ${{ github.workspace }}/vcpkg/vcpkg.exe
          GH_PACKAGES_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}
        run: |
            # Find nuget.exe
            $nuget_path = & "${{ env.VCPKG_EXE }}" fetch nuget | Select-String -Pattern '\S+\.exe$' | ForEach-Object { $_.Matches[0].Value }
            if (-not $nuget_path) { Write-Error "Failed to get nuget.exe path."; exit 1 }
            
            Write-Host "Setting API Key for GitHubPackages source..."
            # Use the setapikey command. The key is the PAT.
            # -Source is used to specify which registered source the API key is for.
            & "$nuget_path" setapikey "${{ env.GH_PACKAGES_TOKEN }}" -Source "GitHubPackages" -NonInteractive 2>&1 | Write-Host
            if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to set API Key for GitHubPackages."
                exit 1
            }
            Write-Host "API Key for GitHubPackages set successfully."

      - name: Debug NuGet Push/Pull Capabilities
        env:
          VCPKG_EXE: ${{ github.workspace }}/vcpkg/vcpkg.exe
          USERNAME: ${{ github.repository_owner }}
          GH_PACKAGES_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }} # No longer used directly by push, but might be for other internal parts of vcpkg
          FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
        run: |
          # Find nuget.exe (re-finding here for clarity, can optimize if needed)
          $nuget_path = & "${{ env.VCPKG_EXE }}" fetch nuget | Select-String -Pattern '\S+\.exe$' | ForEach-Object { $_.Matches[0].Value }
          if (-not $nuget_path) { Write-Error "Failed to get nuget.exe path."; exit 1 }
          
          Write-Host "Attempting a test NuGet push/pull operation..."
          
          # Try to list packages from your feed (pull test)
          Write-Host "--- NuGet List Test ---"
          & "$nuget_path" list -Source "GitHubPackages" 2>&1 | Write-Host
          if ($LASTEXITCODE -ne 0) {
            Write-Error "NuGet list test failed! Check credentials/source or connectivity."
            exit 1
          }
          Write-Host "NuGet list test passed (no direct error from 'nuget list')."
          
          # Try to push a dummy package (push test) - REMOVE THIS AFTER DEBUGGING!
          # This step will only run if the 'list' command succeeded.
          Write-Host "--- NuGet Push Test ---"
          $dummyPackageId = "DummyTestPackage.${{ github.run_id }}.${{ github.run_attempt }}-${{ runner.os }}"
          $dummyPackageVersion = "1.0.0"
          $dummyPackageNupkg = "$dummyPackageId.$dummyPackageVersion.nupkg"
          
          New-Item -Path . -Name "$dummyPackageId.nuspec" -ItemType File -Value @"
          <?xml version="1.0" encoding="utf-8"?>
          <package>
          <metadata>
          <id>$dummyPackageId</id>
          <version>$dummyPackageVersion</version>
          <authors>CI Test User</authors>
          <description>A dummy package for CI testing of NuGet push.</description>
          </metadata>
          </package>
          "@ | Out-Null
          
          Write-Host "Creating dummy package '$dummyPackageId.nuspec'..."
          & "$nuget_path" pack "$dummyPackageId.nuspec" -OutputDirectory . -NoDefaultExcludes 2>&1 | Write-Host
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Dummy package creation failed."
            exit 1
          }
          
          Write-Host "Attempting to push $dummyPackageNupkg to GitHub Packages..."
          # REMOVED: --api-key. It should now pick up the key saved by setapikey.
          & "$nuget_path" push "$dummyPackageNupkg" -Source "GitHubPackages" -SkipDuplicate -Verbosity detailed -Debug 2>&1 | Write-Host
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Dummy package push failed! This is the core issue with authentication."
            exit 1
          }
          
         Write-Host "Dummy package pushed successfully (or skipped if duplicate)."

      # Step 6: Configure CMake and trigger Vcpkg install
      # Vcpkg will automatically use the configured binary cache.
      - name: Configure CMake and Install Vcpkg Dependencies
        working-directory: ${{ github.workspace }}/it-tools-editor
        if: false
        env:
          # Crucial: This tells vcpkg to look for binary packages using NuGet.
          # It uses the feed configured in the previous step.
          VCPKG_BINARY_SOURCES: "clear;nuget,https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json,readwrite"
          # Optional: Specify Vcpkg install options, e.g., debug output
          VCPKG_INSTALL_OPTIONS: "--debug"
          VCPKG_NUGET_ACCESSTOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}
          VCPKG_NUGET_CONFIG: "$env:APPDATA\NuGet\NuGet.Config"
        run: |
          $ninja_path = (Get-Command ninja -ErrorAction SilentlyContinue).Path
          if (-not $ninja_path) {
            Write-Error "Ninja not found in PATH!"
            exit 1
          }
          
          Write-Host "Found Ninja at: $ninja_path" # Diagnostic: Print the path

          cmake -B build `
                -S . `
                -G "Ninja" `
                -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake `
                -DCMAKE_MAKE_PROGRAM="$ninja_path" `
                -DVCPKG_TARGET_TRIPLET=x64-mingw-dynamic # Adjust triplet as per your needs
        shell: pwsh # Use cmd shell for typical Windows commands and path syntax

      # Step 7: Build the Project
      - name: Build Project
        working-directory: ${{ github.workspace }}/it-tools-editor/build
        run: cmake --build .
        shell: cmd